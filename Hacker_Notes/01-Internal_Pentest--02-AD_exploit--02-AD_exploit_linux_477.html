<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>02-AD exploit linux</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>02-AD exploit linux</h1><br/><p><a href="https://orange-cyberdefense.github.io/ocd-mindmaps/img/mindmap_ad_dark_classic_2025.03.excalidraw.svg">https://orange-cyberdefense.github.io/ocd-mindmaps/img/mindmap_ad_dark_classic_2025.03.excalidraw.svg</a></p><p></p><p></p><p><h2>Summary</h2></p><p></p><p>Explique‐moi ton workflow offensif Active Directory, du premier paquet jusqu’à la persistance inter-forêts ». Voilà comment je le raconte en moins de dix minutes :</p><p></p><p> Je démarre toujours par une phase de reconnaissance sans identifiants. Je cartographie le réseau avec Nmap et Responder, j’interroge DNS, LDAP et SMB pour découvrir contrôleurs de domaine, utilisateurs, groupes et partages ouverts. J’alimente immédiatement BloodHound pour visualiser les premiers chemins d’attaque et je tente les “low-hanging fruits” : transfert de zone DNS, SMB v1, signatures désactivées, ou encore AS-REP Roast et Kerbrute pour valider des comptes.</p><p> </p><p>Ensuite, j’enchaîne sur la compromission rapide. Si un service vulnérable est exposé — Zerologon, EternalBlue, ProxyShell, Veeam, Log4Shell, Tomcat Manager — je vise un shell SYSTEM ou un compte service privilégié. L’idée est d’obtenir au moins un premier pied dans le domaine avant de déclencher des scans plus bruyants.</p><p></p><p>Dès que j’ai un ou plusieurs comptes, je passe au password-spray calibré sur la politique de verrouillage : d’abord “user = password”, puis les classiques “SeasonYear!” et “Company123”. En parallèle, je roast : AS-REP pour les comptes « no-pre-auth », Kerberoast pour les SPN. Tout hash récupéré part au cracking hors ligne.</p><p></p><p>Quand aucun mot de passe ne sort, je pivote sur le Man-in-the-Middle. Responder, mitm6 et ntlmrelayx me permettent de relayer NTLM vers LDAP S ; j’en profite pour ajouter un ordinateur, élever un utilisateur ou injecter un Shadow Credential. S’il existe un serveur Web Enrollment, je relaye directement vers l’AD CS et je récupère un certificat Domain Controller.</p><p></p><p>Une fois authentifié, je lance l’énumération “classique” : BloodHound CE en collecte complète, SharpHound côté Windows, ldeep pour LDAP, adfind pour DNS. Je récupère les ACL, délégations, PSO, gMSA, mots de passe LAPS, et je cherche un SCCM ou un AD CS mal configuré. Cette carto précise où je peux élever mes droits sans faire de bruit.</p><p></p><p>Sur les hôtes où je ne suis qu’utilisateur, je m’élève localement : bypass AppLocker, UAC via fodhelper ou wreset, exploits comme SMBGhost ou HiveNightmare, ou encore KrbRelayUp pour un SERVICE TOKEN SYSTEM. Une fois SYSTEM, je dump LSASS, les hives SAM et SECURITY, ou je déclenche un DUMP VSS pour récolter des crédences en clair et des NTLM.</p><p></p><p>En parallèle, j’exploite les vulnérabilités authentifiées : MS14-068, noPac, PrintNightmare, PrivExchange, Certifried. Chacune me donne soit un ticket forgé, soit un DCSYNC direct, soit un accès admin Exchange ou AD CS.</p><p></p><p>Quand un ACL me donne un <strong>GenericWrite</strong>, j’ajoute un msDS-KeyCredentialLink et je fais un Pass-the-Certificate. Si j’ai un <strong>WriteOwner</strong> ou un <strong>WriteDACL</strong> sur un groupe, je m’y ajoute. Sur un ordinateur, j’insère une RBCD ; sur un utilisateur, je force le mot de passe ou j’ajoute un SPN à roaster.</p><p></p><p>Je profite ensuite des délégations Kerberos. Un unconstrained DC victime d’un PetitPotam me livre un TGT ; un compte <code>TRUST_TO_AUTH_FOR_DELEGATION</code> me permet un S4U2Self puis S4U2Proxy, et RBCD m’autorise à usurper n’importe quel service via getST.py.</p><p>Si l’infra contient AD CS, j’abuse les ESC1 à 15 : template “enrollee supplies subject”, EKU client-auth, flag <code>EDITF_ATTRIBUTESUBJECTALTNAME2</code>, ou encore vulnérabilités d’ACL sur les objets PKI. Un simple <code>certipy req</code> me donne un certificat d’admin que je convertis en TGT avec Rubeus.</p><p></p><p>Côté SCCM, je vole d’abord les identifiants NAA via les partages PXE, puis je relaye NTLM vers les rôles site system pour pousser un binaire ou abuser de <code>client push</code>. Avec les droits db_owner sur le SQL SCCM, <code>xp_cmdshell</code> me garantit un shell sur l’ensemble du parc géré.</p><p></p><p>Avec toutes ces crédences, je multiplie les mouvements latéraux : PSExec, WinRM, RDP, SMBexec, ou <code>xp_cmdshell</code> sur les serveurs SQL. Je passe les hash (PTH), les tickets (PTT) ou les certificats (PTC) selon le contexte. Si j’ai besoin d’un tunnel, j’utilise les modules SOCKS d’Impacket pour chaîner SMB ou LDAP derrière un relai.</p><p></p><p>Une fois Domain Admin, je consolide ma persistance. Je peux simplement ajouter un compte au groupe Domain Admins, mais je préfère les méthodes furtives : Golden Ticket avec la clé krbtgt, Silver Ticket ciblé, Golden Certificate si j’ai la CA, Skeleton Key pour un mot de passe universel, modification d’ACL ou DC Shadow pour pousser des attributs malveillants. J’active aussi la connexion DSRM en ligne pour une porte de secours.</p><p></p><p>Finalement, je dump le ntds.dit complet : soit en direct avec secretsdump, soit via <code>ntdsutil IFM</code>, soit en DCSYNC. Je récupère aussi les clés de sauvegarde DPAPI et les certificats privés via DonPAPI afin de pouvoir tout déchiffrer ensuite.</p><p></p><p>Si la forêt possède des trusts, je termine par là : je dumpe la clé de trust sur un DC, je forge un ticket inter-domaine et je propage mes privilèges vers le parent, le child ou un domaine externe, voire je rejoue un Golden Ticket dans toute la forêt.</p><p></p><p>À ce stade, j’ai non seulement le contrôle total du domaine, mais aussi les moyens d’y revenir quand je veux, même après des rotations de mots de passe ou des réinitialisations d’objets critiques. La boucle est complète, de la simple découverte réseau jusqu’à la persistance multi-forêts. »</p></div>
</body>
</html>
