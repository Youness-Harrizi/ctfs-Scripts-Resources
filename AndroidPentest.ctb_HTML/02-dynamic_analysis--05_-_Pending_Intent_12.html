<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>05 - Pending Intent</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>05 - Pending Intent</h1><br/><p>Here’s the course boiled down to what you’ll actually use on an engagement.</p><p></p><p><h1>Concept</h1><ul><li><strong>PendingIntent</strong> = a token that lets another component/app execute code <strong>as your app</strong> later (e.g., via notifications, alarms).</li></ul></p><p><ul><li><strong>Mutable vs Immutable</strong>: <code>FLAG_MUTABLE</code> lets receivers <strong>change</strong> the inner <code>Intent</code> (extras, component) before it runs. That flexibility is the risk: a hostile app can hijack it to make your app perform unintended actions with your app’s permissions.</li></ul></p><p></p><p></p><p></p><p><h1>Attack Surface (what to hunt)</h1><ul><li>App creates a <strong>mutable</strong> <code>PendingIntent</code> (numeric flag <code>33554432</code> or <code>PendingIntent.FLAG_MUTABLE</code>).</li></ul></p><p><ul><li>App <strong>broadcasts</strong> that <code>PendingIntent</code> to anyone (exported receivers or broad actions).</li></ul></p><p><ul><li>Downstream code makes security-relevant decisions based on <strong>extras</strong> (e.g., <code>if (getBooleanExtra(&quot;Secret&quot;, false)) …</code>) without verifying who set them.</li></ul></p><p><ul><li>Sensitive actions chained from that decision (launching a secrets screen, reading a token, calling privileged APIs, etc.).</li></ul></p><p><ul><li>Native library calls (<code>System.loadLibrary(&quot;…&quot;)</code>) that hydrate sensitive values once the gated activity is reached.</li></ul></p><p></p><p></p><p></p><p><h1>Exploit Flow (lab pattern)</h1><ol><li><strong>Recon the APK</strong></li><li><code>apktool d app.apk</code> or open with <code>jadx-gui</code>.</li></ol></p><p><ul><li>Find where a <code>PendingIntent</code> is created with <code>FLAG_MUTABLE</code>.</li></ul></p><p><ul><li>Note any <strong>broadcast</strong> loop sending an <code>Intent</code> that includes this <code>PendingIntent</code> as an extra (e.g., every 5s).</li></ul></p><p><ul><li>Identify the <strong>gated activity</strong> (e.g., <code>MenuActivity</code> → checks <code>Intent</code> extra <code>Secret=true</code> → redirects to <code>SecretActivity</code> → calls a native method to display a token).</li></ul></p><p></p><p></p><p><ul><li><strong>Build a tiny “evil” receiver</strong></li><li>Android Studio project with a <strong>BroadcastReceiver</strong> registered for the target action (e.g., <code>com.example.waiting.RECEIVED</code>).</li></ul></p><p><ul><li>In <code>onReceive</code>, extract the extra:</li></ul></p><p> <code>PendingIntent p = intent.getParcelableExtra(&quot;&lt;EXTRA_KEY&gt;&quot;);</code></p><p><ul><li>Craft a replacement inner intent:</li></ul></p><p> <code>Intent hijack = new Intent(); hijack.putExtra(&quot;Secret&quot;, true);</code></p><p><ul><li>Fire the victim’s <code>PendingIntent</code> <strong>with your extras</strong>:</li></ul></p><p> <code>p.send(context, 0, hijack, null, null);</code></p><p></p><p></p><p><ul><li><strong>Run it</strong></li><li>Install victim app, background it (so its broadcast loop runs).</li></ul></p><p><ul><li>Launch your receiver app; wait for the broadcast; your <code>send()</code> triggers the gated path.</li></ul></p><p><ul><li>Result: secret/token shows up (evidence of <strong>PendingIntent hijack</strong>).</li></ul></p><p></p><p></p><p></p><p></p><p><h1>Tools &amp; Commands</h1><ul><li>ADB: <code>adb install app.apk</code></li></ul></p><p><ul><li>Decompilers: <strong>JADX</strong>, <strong>apktool</strong></li></ul></p><p><ul><li>Android app scaffold: Android Studio (Empty Activity + BroadcastReceiver)</li></ul></p><p></p><p></p><p></p><p><h1>Evidence to Capture</h1><ul><li>Decompiled snippet showing <code>FLAG_MUTABLE</code> and the broadcast that carries the <code>PendingIntent</code>.</li></ul></p><p><ul><li>The gate check (e.g., <code>getBooleanExtra(&quot;Secret&quot;, false)</code>).</li></ul></p><p><ul><li>Your receiver code (short, sanitized).</li></ul></p><p><ul><li>Screenshots/video of secret/token appearing after the hijack.</li></ul></p><p></p><p></p><p></p><p><h1>Detection &amp; Defense (what to recommend)</h1><ul><li><strong>Default to </strong><strong><code>FLAG_IMMUTABLE</code></strong>; only use mutable when strictly necessary.</li></ul></p><p><ul><li>Do <strong>not</strong> place <code>PendingIntent</code>s into broad/unauthenticated broadcasts; scope with permissions and explicit component names.</li></ul></p><p><ul><li>Treat <strong>extras as untrusted input</strong>; validate caller identity (signature perms, <code>PendingIntent.getCreatorPackage()</code>) or add app-only permissions.</li></ul></p><p><ul><li>Avoid exported receivers unless required; prefer <code>sendBroadcast</code> with <strong>permission</strong> or <code>LocalBroadcastManager</code> equivalents.</li></ul></p><p><ul><li>Minimize secrets reachable from UI paths gated only by intent extras; require in-app state checks.</li></ul></p><p></p><p></p><p></p><p><h1>Pentester Checklist (90-second runbook)</h1><ul><li> Search for <code>PendingIntent</code> creation; flag if <code>FLAG_MUTABLE</code> present.</li></ul></p><p><ul><li> Trace how/where the token is <strong>exposed</strong> (broadcast/intent extra).</li></ul></p><p><ul><li> Identify any <strong>gated actions</strong> based solely on extras.</li></ul></p><p><ul><li> Implement a receiver PoC to <strong>modify</strong> the inner intent; prove impact.</li></ul></p><p><ul><li> Document risk: “arbitrary action execution with app’s privileges” + data exposure.</li></ul></p><p><ul><li> Provide fixes: immutable tokens, receiver hardening, caller validation.</li></ul></p><p></p><p></p><p>If you want, I can generate a ready-to-run PoC Android Studio project with the receiver scaffold and placeholder keys so you can drop in any target action/extra names.</p></div>
</body>
</html>
