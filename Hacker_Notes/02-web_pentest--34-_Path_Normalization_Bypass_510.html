<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>34- Path Normalization Bypass</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>34- Path Normalization Bypass</h1><br/><p><h2>Ressource #1</h2></p><p><a href="https://www.youtube.com/watch?v=kF4UeEmH0fc">https://www.youtube.com/watch?v=kF4UeEmH0fc</a></p><p></p><p><h2>Vuln #1</h2></p><p>The video demonstrates a <strong>Path Normalization Bypass</strong> vulnerability where a discrepancy in how a reverse proxy (Nginx) and a backend application (Flask) parse URLs allows an attacker to bypass access controls.</p><p>Here is the technical breakdown of the exploit:</p><p></p><p><h3>The Architecture</h3><ul><li><strong>Reverse Proxy:</strong> Nginx is listening on port 80. It has a specific rule to <code>deny</code> requests to the exact path <code>/admin</code>. All other requests are proxied to the backend.</li></ul></p><p><ul><li><strong>Backend:</strong> A Flask application running on port 5000.</li></ul></p><p></p><p></p><p></p><p><h3>The Vulnerability</h3></p><p>The core issue is <strong>inconsistent URL parsing/normalization</strong>.<ol><li><strong>Nginx&#39;s View:</strong> Nginx is configured to block <code>/admin</code>. If it sees a request for <code>/admin&lt;special_char&gt;</code>, it treats it as a <em>different</em> path (e.g., a file named <code>admin&lt;char&gt;</code>), so the block rule is <strong>not</strong> triggered, and the request is forwarded to the backend.</li></ol></p><p><ol><li><strong>Flask&#39;s View:</strong> When Flask receives the forwarded request for <code>/admin&lt;special_char&gt;</code>, its URL normalization logic (or the underlying WSGI server&#39;s logic) strips out the invalid or special character, interpreting the request simply as <code>/admin</code>.</li></ol></p><p></p><p></p><p><h3>The Exploit</h3></p><p>The video uses the byte <code>0x85</code> (Next Line character in some encodings) to achieve this desynchronization.<ul><li><strong>Attack Payload:</strong> <code>GET /admin%85 HTTP/1.1</code> (decoded as <code>/admin</code> followed by byte <code>0x85</code>).</li></ul></p><p><ul><li><strong>Execution:</strong></li><li>Nginx sees <code>/admin\x85</code>. It checks its rules: is this <code>/admin</code>? No. It forwards the traffic.</li></ul></p><p><ol><li>Flask receives <code>/admin\x85</code>. It normalizes the path, stripping the <code>\x85</code>, and routes the request to the <code>/admin</code> endpoint.</li></ol></p><p><ol><li><strong>Result:</strong> You get a <code>200 OK</code> with the admin content, bypassing the Nginx <code>403 Forbidden</code>.</li></ol></p><p></p><p></p><p></p><p></p><p><h3>Remediation</h3></p><p>The video suggests updating the Nginx configuration to use a regex match rather than a simple prefix or exact match.</p><p><strong>Vulnerable Config:</strong></p><p>Nginx</p><p></p><p>location /admin {</p><p>    deny all;</p><p>}<code></code></p><p><code></code></p><p></p><p></p><p><strong>Secure Config:</strong></p><p><span style="color:#444746;">Nginx</span></p><p></p><p># ~* makes it case-insensitive regex match</p><p># ^/admin ensures it matches anything STARTING with /admin</p><p>location ~* ^/admin {</p><p>    deny all;<code></code></p><p><code>}</code><code></code></p><p><code></code></p><p></p><p></p><p>This prevents the bypass because Nginx will now block any path that <em>starts</em> with <code>/admin</code>, regardless of what characters follow.</p><p></p><p></p><p></p><p><h2>Path Normalization LFI</h2></p><p></p><p># Vulnerable nginx conf </p><p></p><p>server {</p><p>    listen 80;</p><p>    server_name another-awesome-challenge.com;</p><p></p><p>    location /backend { </p><p>        proxy_pass <a href="http://backend/;">http://backend/;</a></p><p>    }</p><p>    </p><p>    location /html {</p><p>        alias /usr/share/nginx/html/;</p><p>    }</p><p>}</p><p><strong><span style="color:#569cd6;"># My Solution</span></strong></p><p></p><p><span style="color:#333333;">So... What&#39;s the problem with this innocent-looking Nginx configuration? The answer is path normalization. Say someone visits </span><span style="color:#ce9178;">`https://&lt;host&gt;/html../nginx.conf`</span><span style="color:#333333;">. Remember that </span><span style="color:#ce9178;">`/html`</span><span style="color:#333333;"> is an alias for </span><span style="color:#ce9178;">`/usr/share/nginx/html/`</span><span style="color:#333333;"> which means that Nginx would interpret this as </span><span style="color:#ce9178;">`/usr/share/nginx/html/../nginx.conf`</span><span style="color:#333333;">. Thus, an attacker can break out of the designated path and we have a classic LFI vulnerability.</span></p><p></p><p><span style="color:#333333;">To remediate this, we can e.g. change the alias to something like this:</span></p><p></p><p><span style="color:#333333;">```</span></p><p><span style="color:#333333;">location /html/ {</span></p><p><span style="color:#333333;">Â root /usr/share/nginx/html;</span></p><p><span style="color:#333333;">}</span></p><p><span style="color:#333333;">```</span></p><p></p><p><span style="color:#333333;">Now, if an attacker again visits </span><span style="color:#ce9178;">`https://&lt;host&gt;/html../nginx.conf`</span><span style="color:#333333;">, Nginx would not map this to our </span><span style="color:#ce9178;">`/html/`</span><span style="color:#333333;"> rule anymore, and throw a 404.</span></p><p></p><p></p></div>
</body>
</html>
